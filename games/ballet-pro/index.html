<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>çš‡å®¶è›‹ç³•å¡” - åŒæ‘„ä½“æ„Ÿæ¸¸æˆ</title>
  
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

  <style>
    body { margin: 0; background: #000; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
    .hidden { display: none !important; }
    
    /* é¦–é¡µ & UI */
    #screen-select { height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; background: linear-gradient(135deg, #2c3e50, #000); }
    .btn { padding: 15px 40px; font-size: 20px; border-radius: 30px; border: none; font-weight: bold; cursor: pointer; transition: transform 0.2s; text-transform: uppercase; letter-spacing: 1px;}
    .btn:active { transform: scale(0.95); }
    .btn-main { background: #f1c40f; color: #000; box-shadow: 0 0 20px rgba(241, 196, 15, 0.4); }
    .btn-side { background: #3498db; color: white; }

    /* æ¸¸æˆä¸»ç•Œé¢ */
    #screen-main { position: relative; width: 100vw; height: 100vh; background: #000; }
    
    /* è§†é¢‘ä¸ç”»å¸ƒ */
    #video-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    video#video-main { display: none; }
    canvas#canvas-main { width: 100%; height: 100%; object-fit: contain; }

    /* æ¸¸æˆUIå±‚ */
    #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    
    /* é¡¶éƒ¨ä»ªè¡¨ç›˜ */
    .hud-panel { position: absolute; top: 20px; left: 20px; display: flex; gap: 15px; }
    .hud-box { background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 12px; border: 2px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; align-items: center;}
    .hud-label { font-size: 12px; color: #aaa; }
    .hud-value { font-size: 24px; font-weight: bold; color: #f1c40f; }

    /* ä¾§é¢çŠ¶æ€ç¯ */
    .side-indicator { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 20px; display: flex; align-items: center; gap: 8px; border: 1px solid #555;}
    .led { width: 10px; height: 10px; border-radius: 50%; background: #555; transition: all 0.3s; }
    .led.on { background: #2ecc71; box-shadow: 0 0 10px #2ecc71; }
    .led.error { background: #e74c3c; box-shadow: 0 0 10px #e74c3c; }

    /* å¹³è¡¡æ¡ */
    .balance-meter { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); width: 300px; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; overflow: hidden;}
    .balance-fill { height: 100%; background: #f1c40f; width: 50%; margin-left: 25%; transition: width 0.1s, margin-left 0.1s; }

    /* æ¸¸æˆå¼€å§‹/ç»“æŸé®ç½© */
    #overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 100;}
    .title-text { font-size: 60px; font-weight: 900; color: #f1c40f; margin-bottom: 10px; text-shadow: 0 0 20px rgba(241,196,15,0.5); }
    .subtitle-text { font-size: 24px; color: #ddd; margin-bottom: 40px; }
    
    /* å³ä¸‹è§’æ§åˆ¶ */
    .controls { position: absolute; bottom: 20px; right: 20px; display: flex; gap: 10px; pointer-events: auto;}
    .icon-btn { background: rgba(0,0,0,0.6); border: 1px solid #555; color: white; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px;}

    /* ä¾§é¢ç”»ä¸­ç”» */
    #side-pip { position: absolute; bottom: 80px; right: 20px; width: 160px; height: 120px; background: #000; border: 2px solid #333; border-radius: 8px; overflow: hidden; display: none; }
    #video-remote { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

    #qr-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 200; }
    .qr-box { background: white; padding: 30px; border-radius: 16px; text-align: center; color: black; }

    /* è¾…æœºç•Œé¢ */
    #screen-side { height: 100vh; background: #111; display: flex; flex-direction: column; align-items: center; padding-top: 40px; }
    #video-side { width: 60vw; height: 80vw; object-fit: cover; border-radius: 12px; border: 2px solid #3498db; transform: scaleX(-1); background: #000;}
  </style>
</head>
<body>

  <div id="screen-select">
    <h1 style="font-size: 40px; margin-bottom: 10px;">ğŸ‘‘ çš‡å®¶è›‹ç³•å¡”</h1>
    <p style="color:#aaa; margin-bottom: 40px;">åŒæ‘„ä½“æ„Ÿå¹³è¡¡æŒ‘æˆ˜</p>
    <button class="btn btn-main" onclick="initMain()">æˆ‘æ˜¯ä¸»æœº (å¼€å§‹æ¸¸æˆ)</button>
    <button class="btn btn-side" onclick="initSide()">æˆ‘æ˜¯è¾…æœº (ä¾§é¢è£åˆ¤)</button>
  </div>

  <div id="screen-main" class="hidden">
    <div id="video-container">
        <video id="video-main" playsinline muted autoplay></video>
        <canvas id="canvas-main"></canvas>
    </div>

    <div id="game-ui">
        <div class="hud-panel">
            <div class="hud-box">
                <span class="hud-label">å¾—åˆ†</span>
                <span class="hud-value" id="score-display">0</span>
            </div>
            <div class="hud-box">
                <span class="hud-label">æ—¶é—´</span>
                <span class="hud-value" id="time-display">00:00</span>
            </div>
        </div>

        <div class="side-indicator">
            <div id="side-led" class="led"></div>
            <span id="side-text">ä¾§é¢æœªè¿æ¥</span>
        </div>

        <div class="balance-meter">
            <div id="balance-bar" class="balance-fill"></div>
        </div>

        <div id="side-pip">
            <video id="video-remote" autoplay playsinline muted></video>
        </div>

        <div class="controls">
            <button class="icon-btn" onclick="showQrCode()" title="è¿æ¥è¾…æœº">ğŸ”—</button>
            <button class="icon-btn" onclick="toggleDebug()" title="éª¨éª¼å¼€å…³">ğŸ’€</button>
        </div>
    </div>

    <div id="overlay-screen">
        <div class="title-text" id="overlay-title">çš‡å®¶è›‹ç³•å¡”</div>
        <div class="subtitle-text" id="overlay-sub">ä¿æŒæ­£ç›´ï¼Œä¸è¦è®©è›‹ç³•æ‰ä¸‹æ¥ï¼</div>
        <button class="btn btn-main" id="btn-start-game" onclick="startGame()">å¼€å§‹æŒ‘æˆ˜</button>
    </div>

    <div id="qr-modal" class="hidden">
        <div class="qr-box">
            <h3>æ‰«ç è¿æ¥ä¾§é¢è£åˆ¤</h3>
            <div id="qrcode"></div>
            <br>
            <button onclick="document.getElementById('qr-modal').classList.add('hidden')" style="padding:5px 20px;">å…³é—­</button>
        </div>
    </div>
  </div>

  <div id="screen-side" class="hidden">
    <h3 style="color: #3498db;">ä¾§é¢è£åˆ¤è¿è¡Œä¸­</h3>
    <div id="side-status" style="color: #aaa;">æ­£åœ¨è¿æ¥...</div>
    <video id="video-side" playsinline muted autoplay></video>
    <div id="side-log" style="font-family: monospace; color: #2ecc71; margin-top: 20px;">ç­‰å¾…å¼€å§‹...</div>
  </div>

  <script>
    // --- æ¸¸æˆå¼•æ“é…ç½® ---
    const GAME_CONFIG = {
        gravity: 0.2,
        balanceDecay: 0.5, // å€¾æ–œæ—¶çš„æ‰£è¡€é€Ÿåº¦
        scoreRate: 10,     // æ¯ç§’å¾—åˆ†
        sidePenalty: 2.0   // ä¾§é¢é”™è¯¯æ—¶çš„æ‰£è¡€å€ç‡
    };

    // --- å…¨å±€å˜é‡ ---
    let gameState = 'menu'; // menu, playing, gameover
    let score = 0;
    let gameTime = 0;
    let gameInterval;
    let cakeBalance = 50; // 0-100, 50 is center
    let cakeSway = 0; // å½“å‰æ™ƒåŠ¨è§’åº¦
    let showDebugSkeleton = true;

    // ä¾§é¢æ•°æ®
    let sideData = { active: false, errors: [] };
    
    // Mediapipe & WebRTC
    let poseMain, peer, conn;

    // ================= æ¸¸æˆé€»è¾‘æ ¸å¿ƒ =================

    function startGame() {
        document.getElementById('overlay-screen').classList.add('hidden');
        gameState = 'playing';
        score = 0;
        gameTime = 0;
        cakeBalance = 50;
        cakeSway = 0;
        
        // å¯åŠ¨è®¡æ—¶å™¨
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(updateGameLoop, 100);
    }

    function updateGameLoop() {
        if (gameState !== 'playing') return;

        // 1. å¢åŠ æ—¶é—´
        gameTime += 0.1;
        let mins = Math.floor(gameTime / 60);
        let secs = Math.floor(gameTime % 60);
        document.getElementById('time-display').innerText = `${mins}:${secs < 10 ? '0'+secs : secs}`;

        // 2. å¢åŠ åˆ†æ•° (å¦‚æœå¹³è¡¡å¥½)
        if (Math.abs(cakeBalance - 50) < 10 && sideData.errors.length === 0) {
            score += GAME_CONFIG.scoreRate / 10;
            document.getElementById('score-display').innerText = Math.floor(score);
        }

        // 3. ä¾§é¢æƒ©ç½šé€»è¾‘
        if (sideData.active && sideData.errors.length > 0) {
            // ä¾§é¢æœ‰é—®é¢˜ï¼Œè›‹ç³•å‰§çƒˆæ™ƒåŠ¨ï¼Œå¹³è¡¡æ¡ç¼©å‡
            cakeSway = (Math.random() - 0.5) * 40; // å‰§çƒˆæŠ–åŠ¨
            // è‡ªåŠ¨åå‘ä¸€è¾¹å¯¼è‡´æ‰è½
            if (cakeBalance > 50) cakeBalance += GAME_CONFIG.sidePenalty;
            else cakeBalance -= GAME_CONFIG.sidePenalty;
        } else {
            // æ¢å¤å¹³ç¨³
            cakeSway *= 0.9;
        }

        // 4. æ£€æŸ¥å¤±è´¥
        if (cakeBalance <= 0 || cakeBalance >= 100) {
            gameOver();
        }

        // æ›´æ–°UIæ¡
        const bar = document.getElementById('balance-bar');
        bar.style.marginLeft = `${cakeBalance / 2}%`; // 0-100 map to 0-50 margin
        
        // å˜è‰²é¢„è­¦
        if (Math.abs(cakeBalance - 50) > 30) bar.style.background = '#e74c3c';
        else bar.style.background = '#f1c40f';
    }

    function gameOver() {
        gameState = 'gameover';
        clearInterval(gameInterval);
        
        document.getElementById('overlay-title').innerText = "è›‹ç³•æ‰äº†ï¼ğŸ˜­";
        document.getElementById('overlay-sub').innerText = `æœ€ç»ˆå¾—åˆ†: ${Math.floor(score)}`;
        document.getElementById('btn-start-game').innerText = "å†è¯•ä¸€æ¬¡";
        document.getElementById('overlay-screen').classList.remove('hidden');
    }

    function toggleDebug() {
        showDebugSkeleton = !showDebugSkeleton;
    }

    // ================= æ¸²æŸ“é€»è¾‘ (Canvas) =================

    function onMainResults(results) {
        const canvas = document.getElementById('canvas-main');
        const ctx = canvas.getContext('2d');
        
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. ç»˜åˆ¶è§†é¢‘èƒŒæ™¯ (é•œåƒ)
        ctx.scale(-1, 1);
        ctx.translate(-canvas.width, 0);
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        
        if (results.poseLandmarks) {
            const lm = results.poseLandmarks;
            
            // 2. ç»˜åˆ¶éª¨éª¼ (å¯é€‰)
            if (showDebugSkeleton) {
                drawConnectors(ctx, lm, POSE_CONNECTIONS, {color: 'rgba(255, 255, 255, 0.3)', lineWidth: 2});
            }

            // 3. æ¸¸æˆé€»è¾‘ï¼šè®¡ç®—è‚©è†€å€¾æ–œ
            // å·¦è‚©(11), å³è‚©(12)
            const leftShoulder = lm[11];
            const rightShoulder = lm[12];
            
            // è®¡ç®—å€¾æ–œè§’åº¦ (ç®€å• Y å·®å€¼)
            // æ³¨æ„ï¼šé•œåƒåï¼Œå·¦è¾¹æ˜¯å³è‚©ï¼Œå³è¾¹æ˜¯å·¦è‚©
            const tilt = (leftShoulder.y - rightShoulder.y) * 500; // æ”¾å¤§ç³»æ•°
            
            if (gameState === 'playing') {
                // ç‰©ç†å¼•æ“ï¼šå€¾æ–œå½±å“å¹³è¡¡
                // å¦‚æœå·¦è‚©é«˜ (yå°)ï¼Œtilt æ˜¯è´Ÿæ•°ï¼Œè›‹ç³•å¾€å³æ»‘
                cakeBalance += tilt * 0.1; 
                // é™åˆ¶èŒƒå›´
                cakeBalance = Math.max(0, Math.min(100, cakeBalance));
            }

            // 4. ç»˜åˆ¶è›‹ç³•å¡” (Inject Game Assets)
            drawCakeTower(ctx, lm, tilt);
        }
        ctx.restore();
    }

    function drawCakeTower(ctx, lm, tilt) {
        // æ‰¾åˆ°å¤´é¡¶åæ ‡ (ä»¥é¼»å°–ä¸ºåŸºå‡†å‘ä¸Š)
        const nose = lm[0];
        const earL = lm[7];
        const earR = lm[8];
        
        // è®¡ç®—å¤´éƒ¨å®½åº¦ä½œä¸ºè›‹ç³•æ¯”ä¾‹å°º
        const headWidth = Math.abs(earL.x - earR.x) * ctx.canvas.width;
        const centerX = nose.x * ctx.canvas.width;
        const centerY = (nose.y * ctx.canvas.height) - (headWidth * 0.8);

        // è›‹ç³•å‚æ•°
        const wobble = (cakeBalance - 50) * 0.5 + cakeSway; // å€¾æ–œè§’åº¦
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(wobble * Math.PI / 180); // è›‹ç³•éšå¹³è¡¡æ‘‡æ‘†

        // ç¬¬ä¸€å±‚ (åº•)
        ctx.fillStyle = "#f1c40f";
        ctx.fillRect(-headWidth, -40, headWidth * 2, 40);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.strokeRect(-headWidth, -40, headWidth * 2, 40);

        // ç¬¬äºŒå±‚ (ä¸­)
        ctx.fillStyle = "#e67e22";
        ctx.fillRect(-headWidth*0.8, -80, headWidth * 1.6, 40);
        ctx.strokeRect(-headWidth*0.8, -80, headWidth * 1.6, 40);

        // ç¬¬ä¸‰å±‚ (é¡¶)
        ctx.fillStyle = "#e74c3c";
        ctx.fillRect(-headWidth*0.6, -110, headWidth * 1.2, 30);
        ctx.strokeRect(-headWidth*0.6, -110, headWidth * 1.2, 30);

        // èœ¡çƒ›/æ¨±æ¡ƒ
        ctx.beginPath();
        ctx.arc(0, -120, 10, 0, Math.PI*2);
        ctx.fillStyle = "red";
        ctx.fill();

        // ä¾§é¢é”™è¯¯æç¤º (å¦‚æœä¾§é¢æŠ¥è­¦ï¼Œè›‹ç³•å†’çƒŸ)
        if (sideData.active && sideData.errors.length > 0) {
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.font = "bold 40px Arial";
            ctx.fillText("âš ï¸", -20, -150);
        }

        ctx.restore();
    }

    // ================= ç³»ç»Ÿåˆå§‹åŒ– =================

    function initMain() {
        document.getElementById('screen-select').classList.add('hidden');
        document.getElementById('screen-main').classList.remove('hidden');
        startMainCamera();
        initHostNetwork();
    }

    async function startMainCamera() {
        const video = document.getElementById('video-main');
        const canvas = document.getElementById('canvas-main');
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'user', width: {ideal: 1280}, height: {ideal: 720} } 
            });
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            };
            
            poseMain = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            poseMain.setOptions({modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6});
            poseMain.onResults(onMainResults);
            
            const camera = new Camera(video, {
                onFrame: async () => { await poseMain.send({image: video}); },
                width: 1280, height: 720
            });
            camera.start();
        } catch(e) { alert("æ‘„åƒå¤´é”™è¯¯: " + e); }
    }

    // ... (æ­¤å¤„ä¿ç•™ PeerJS ç½‘ç»œè¿æ¥é€»è¾‘ï¼Œä¸ä¸Šä¸€ç‰ˆç›¸åŒ) ...
    function generateRoomId() { return Math.floor(10000 + Math.random() * 90000).toString(); }
    
    function showQrCode() { document.getElementById('qr-modal').classList.remove('hidden'); }

    function initHostNetwork() {
      const roomId = generateRoomId();
      const sideUrl = `${window.location.href.split('?')[0]}?role=side&room=${roomId}`;
      document.getElementById("qrcode").innerHTML = "";
      new QRCode(document.getElementById("qrcode"), { text: sideUrl, width: 180, height: 180 });

      peer = new Peer(`dance-host-${roomId}`);
      peer.on('connection', (c) => {
        conn = c;
        handleSideConnection();
      });
      peer.on('call', (call) => {
          call.answer();
          call.on('stream', (s) => {
              document.getElementById('side-pip').style.display = 'block';
              document.getElementById('video-remote').srcObject = s;
          });
      });
    }

    function handleSideConnection() {
        document.getElementById('qr-modal').classList.add('hidden');
        document.getElementById('side-led').classList.add('on');
        document.getElementById('side-text').innerText = "ä¾§é¢å·²è¿æ¥";
        document.getElementById('side-text').style.color = "#2ecc71";
        
        conn.on('data', (data) => { 
            sideData = data; 
            const led = document.getElementById('side-led');
            const text = document.getElementById('side-text');
            
            if (data.errors.length > 0) {
                led.className = "led error";
                text.innerText = data.errors[0]; // æ˜¾ç¤ºå…·ä½“é”™è¯¯ (å‰å€¾/åä»°)
                text.style.color = "#e74c3c";
            } else {
                led.className = "led on";
                text.innerText = "ä¾§é¢æ­£å¸¸";
                text.style.color = "#2ecc71";
            }
        });
    }

    // === è¾…æœºé€»è¾‘ (ä¿æŒä¸å˜) ===
    function initSide() {
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('room');
        if(!roomId) return alert("è¯·å…ˆæ‰«ç ");
        
        document.getElementById('screen-select').classList.add('hidden');
        document.getElementById('screen-side').classList.remove('hidden');

        peer = new Peer();
        peer.on('open', () => {
            document.getElementById('side-status').innerText = "è¿æ¥ä¸­...";
            conn = peer.connect(`dance-host-${roomId}`);
            conn.on('open', () => {
                document.getElementById('side-status').innerText = "âœ… å·²è¿æ¥ (å‰ç½®ç›‘æ§)";
                startSideCameraAndCall(`dance-host-${roomId}`);
            });
        });
    }

    async function startSideCameraAndCall(hostId) {
      const video = document.getElementById('video-side');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user', width: 640, height: 480 }, audio: false 
        });
        video.srcObject = stream;
        peer.call(hostId, stream); // æ¨æµ

        poseSide = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
        poseSide.setOptions({modelComplexity: 0});
        poseSide.onResults(onSideResults);

        const camera = new Camera(video, {
          onFrame: async () => { await poseSide.send({image: video}); },
          width: 640, height: 480
        });
        camera.start();
      } catch(e) { alert("æ‘„åƒå¤´å¤±è´¥:" + e); }
    }

    let lastSend = 0;
    function onSideResults(results) {
      if (!conn || !conn.open) return;
      if (Date.now() - lastSend < 100) return;
      lastSend = Date.now();

      let errors = [];
      if (results.poseLandmarks) {
        const lm = results.poseLandmarks;
        let isLeft = lm[7].visibility > lm[8].visibility;
        let shoulder = isLeft ? lm[11] : lm[12];
        let hip = isLeft ? lm[23] : lm[24];
        let lean = shoulder.x - hip.x;
        
        // ä¾§é¢åˆ¤å®šé€»è¾‘
        if (Math.abs(lean) > 0.08) errors.push(lean > 0 ? "âš  åä»°" : "âš  å‰å€¾");
        
        document.getElementById('side-log').innerText = errors.length > 0 ? errors[0] : "ä½“æ€æ­£å¸¸";
      }
      conn.send({ active: true, errors: errors });
    }

    if(new URLSearchParams(window.location.search).get('role') === 'side') initSide();
  </script>
</body>
</html>