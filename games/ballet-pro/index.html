<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DanceCam - 节奏跟舞版</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 游戏专用动效 */
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    body { background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; user-select: none; }
    
    /* 游戏舞台 */
    #stage { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    
    /* 背景参考视频 (老师) */
    #refVideo { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        object-fit: contain; opacity: 0.8; z-index: 1; 
    }
    
    /* 玩家骨架层 (叠在老师上面) */
    #gameCanvas { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        object-fit: contain; z-index: 2; pointer-events: none;
    }

    /* 摄像头预览 (小窗口) */
    #camPreview {
        position: absolute; bottom: 20px; right: 20px; width: 160px; height: 240px;
        border-radius: 12px; border: 2px solid rgba(255,255,255,0.3); 
        object-fit: cover; z-index: 10; transform: scaleX(-1);
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    /* UI 层 */
    #uiLayer { position: absolute; inset: 0; z-index: 20; pointer-events: none; }
    
    /* 连击展示 */
    .combo-box { 
        position: absolute; top: 10%; left: 5%; 
        text-align: center; transform: rotate(-5deg);
    }
    .combo-num { font-size: 5rem; font-weight: 900; color: #fbbf24; text-shadow: 0 0 20px #d97706; line-height: 1;}
    .combo-label { font-size: 1.5rem; color: #fff; letter-spacing: 0.2em; }

    /* 判定反馈文字 (Perfect/Miss) */
    #feedback {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 6rem; font-weight: 900; opacity: 0;
        text-shadow: 0 0 30px currentColor;
        transition: transform 0.1s;
    }
    .fb-perfect { color: #34d399; animation: pop-text 0.5s forwards; }
    .fb-good { color: #60a5fa; animation: pop-text 0.5s forwards; }
    .fb-miss { color: #f87171; animation: shake 0.4s forwards; }

    /* 节奏条 (Timeline) */
    .timeline-track {
        position: absolute; bottom: 100px; left: 10%; width: 80%; height: 4px;
        background: rgba(255,255,255,0.2); border-radius: 2px;
        display: flex; align-items: center;
    }
    .hit-zone {
        position: absolute; left: 20%; width: 60px; height: 60px;
        border: 4px solid #fff; border-radius: 50%; transform: translate(-50%, 0);
        box-shadow: 0 0 20px rgba(255,255,255,0.5);
        background: rgba(255,255,255,0.1);
    }
    .note {
        position: absolute; width: 30px; height: 30px; border-radius: 50%;
        background: #34d399; box-shadow: 0 0 10px #34d399;
        transform: translate(-50%, 0);
        transition: left 0.1s linear;
    }

    /* 菜单/遮罩 */
    #menu { 
        position: absolute; inset: 0; background: rgba(15, 23, 42, 0.95); 
        z-index: 50; display: flex; flex-direction: column; 
        align-items: center; justify-content: center; pointer-events: auto;
    }

    /* 动画 */
    @keyframes pop-text {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }
    @keyframes shake {
        0%, 100% { transform: translate(-50%, -50%) translateX(0); opacity: 1;}
        25% { transform: translate(-50%, -50%) translateX(-10px); }
        75% { transform: translate(-50%, -50%) translateX(10px); opacity: 0;}
    }
    .hidden { display: none !important; }
  </style>
</head>
<body>

  <div id="stage">
    <video id="refVideo" playsinline></video>
    <canvas id="gameCanvas"></canvas>
    
    <video id="camPreview" autoplay muted playsinline></video>

    <div id="uiLayer">
        <div class="absolute top-6 right-8 text-right">
            <div class="text-xl text-blue-300">SCORE</div>
            <div id="scoreVal" class="text-5xl font-bold text-white tabular-nums">000000</div>
        </div>

        <div class="combo-box">
            <div id="comboVal" class="combo-num">0</div>
            <div class="combo-label">COMBO</div>
        </div>

        <div id="feedback"></div>

        <div class="timeline-track" id="timeline">
            <div class="hit-zone"></div>
            </div>
    </div>
  </div>

  <div id="menu">
    <h1 class="text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500 mb-8 drop-shadow-2xl">
        DANCE CAM
    </h1>
    <p class="text-slate-400 mb-12 text-xl">让你的动作与影子重合</p>
    
    <div class="flex flex-col gap-4 w-64">
        <input id="fileInput" type="file" accept="video/*" class="hidden">
        <button id="btnLoad" class="bg-slate-800 hover:bg-slate-700 text-white py-4 rounded-xl font-bold transition-all ring-1 ring-white/20">
            1. 选择舞蹈视频
        </button>
        <button id="btnCam" class="bg-slate-800 hover:bg-slate-700 text-white py-4 rounded-xl font-bold transition-all ring-1 ring-white/20">
            2. 打开摄像头
        </button>
        <button id="btnStart" class="bg-gradient-to-r from-emerald-500 to-teal-600 hover:scale-105 text-white py-4 rounded-xl font-bold text-xl shadow-lg shadow-emerald-500/30 transition-all disabled:opacity-50 disabled:hover:scale-100" disabled>
            3. 开始游戏
        </button>
    </div>
    <div id="status" class="mt-6 text-slate-500 font-mono text-sm">等待资源...</div>
  </div>

  <script type="module">
    import { FilesetResolver, PoseLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    // ===== 全局变量 =====
    let poseLandmarker;
    let videoFile = null;
    let refAnalysis = { frames: [], beats: [] }; // 存储分析好的骨架数据
    let gameState = 'idle'; // idle, analyzing, playing
    let score = 0, combo = 0, maxCombo = 0;
    
    // 节奏条配置
    const TIMELINE_LOOKAHEAD = 2000; // 提前2秒显示音符
    const HIT_WINDOW = 300; // 判定窗口 ms

    // DOM
    const els = {
        menu: document.getElementById('menu'),
        btnLoad: document.getElementById('btnLoad'),
        fileInput: document.getElementById('fileInput'),
        btnCam: document.getElementById('btnCam'),
        btnStart: document.getElementById('btnStart'),
        status: document.getElementById('status'),
        refVideo: document.getElementById('refVideo'),
        camPreview: document.getElementById('camPreview'),
        canvas: document.getElementById('gameCanvas'),
        timeline: document.getElementById('timeline'),
        feedback: document.getElementById('feedback'),
        score: document.getElementById('scoreVal'),
        combo: document.getElementById('comboVal')
    };
    const ctx = els.canvas.getContext('2d');

    // ===== 1. 初始化 AI =====
    async function initAI() {
        els.status.textContent = "正在加载 AI 模型...";
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numPoses: 1
        });
        els.status.textContent = "AI 就绪。请选择视频。";
    }
    initAI();

    // ===== 2. UI 交互 =====
    els.btnLoad.onclick = () => els.fileInput.click();
    els.fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if(file) {
            videoFile = file;
            els.refVideo.src = URL.createObjectURL(file);
            els.btnLoad.textContent = `✅ ${file.name.substring(0,15)}...`;
            checkReady();
        }
    };

    els.btnCam.onclick = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
            els.camPreview.srcObject = stream;
            els.camPreview.play();
            els.btnCam.textContent = "✅ 摄像头已开启";
            els.btnCam.classList.add('ring-emerald-500');
            checkReady();
        } catch(e) {
            alert("无法开启摄像头: " + e.message);
        }
    };

    function checkReady() {
        if(videoFile && els.camPreview.srcObject && poseLandmarker) {
            els.btnStart.disabled = false;
            els.status.textContent = "准备就绪！点击开始自动分析舞蹈。";
        }
    }

    els.btnStart.onclick = async () => {
        if(gameState === 'analyzing') return;
        // 预分析舞蹈动作
        await analyzeReferenceVideo();
    };

    // ===== 3. 核心：预分析视频 (生成"谱面") =====
    async function analyzeReferenceVideo() {
        gameState = 'analyzing';
        els.btnStart.textContent = "正在分析动作 (请稍候)...";
        els.status.textContent = "AI 正在学习老师的动作...";
        
        refAnalysis.frames = [];
        refAnalysis.beats = [];
        
        // 快速静音播放视频进行分析
        els.refVideo.muted = true;
        els.refVideo.playbackRate = 2.0; // 加速分析
        await els.refVideo.play();
        
        let lastTime = -1;
        let lastPoseEnergy = 0;

        // 分析循环
        const analyzeLoop = async () => {
            if(els.refVideo.paused || els.refVideo.ended) {
                finishAnalysis();
                return;
            }

            const now = els.refVideo.currentTime;
            if(now > lastTime + 0.1) { // 每 100ms 采样一次
                const res = poseLandmarker.detectForVideo(els.refVideo, performance.now());
                if(res.landmarks[0]) {
                    // 存储这一帧的骨架数据
                    refAnalysis.frames.push({
                        time: now,
                        pose: res.landmarks[0] // 存储归一化坐标
                    });

                    // 简单的"重拍"检测：计算动作幅度变化
                    // 这里简化逻辑：每隔 2 秒生成一个判定点 (实际应该用更复杂的动量算法)
                    // 或者检测手部/脚部的剧烈位移
                }
                lastTime = now;
            }
            requestAnimationFrame(analyzeLoop);
        };
        analyzeLoop();
    }

    function finishAnalysis() {
        // 简单的生成拍子：每隔 1.5s 一个 Note
        const duration = els.refVideo.duration;
        for(let t = 2; t < duration - 2; t += 1.5) {
            refAnalysis.beats.push({ time: t, hit: false });
        }

        els.refVideo.pause();
        els.refVideo.currentTime = 0;
        els.refVideo.playbackRate = 1.0;
        els.refVideo.muted = false;
        
        startGame();
    }

    // ===== 4. 游戏循环 =====
    function startGame() {
        gameState = 'playing';
        els.menu.classList.add('hidden');
        score = 0; combo = 0;
        
        // 调整画布尺寸
        els.canvas.width = els.stage.clientWidth;
        els.canvas.height = els.stage.clientHeight;

        els.refVideo.play();
        gameLoop();
    }

    function gameLoop() {
        if(gameState !== 'playing') return;

        const currentTime = els.refVideo.currentTime;
        
        // 1. 绘制 UI：节奏条
        updateTimeline(currentTime);

        // 2. 实时 AI 捕捉玩家
        const playerRes = poseLandmarker.detectForVideo(els.camPreview, performance.now());
        
        // 3. 获取当前的老师动作 (插值查找)
        const refFrame = refAnalysis.frames.find(f => Math.abs(f.time - currentTime) < 0.1);

        // 4. 渲染画面
        ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);
        
        if (refFrame && playerRes.landmarks[0]) {
            const playerPose = playerRes.landmarks[0];
            const refPose = refFrame.pose;

            // 绘制玩家骨架 (绿色) - 叠加在画面上
            drawPose(ctx, playerPose, '#34d399', 4); 
            
            // 绘制老师骨架 (白色幽灵) - 稍微透明
            // 注意：如果 refVideo 已经在背景播放，其实不需要画骨架，
            // 但为了提示，我们可以画一个"目标骨架"提示用户动作幅度
            // drawPose(ctx, refPose, 'rgba(255,255,255,0.3)', 2);

            // 5. 判定逻辑
            checkHit(currentTime, playerPose, refPose);
        }

        // 检查结束
        if(els.refVideo.ended) {
            alert(`游戏结束！得分: ${score}`);
            location.reload();
            return;
        }

        requestAnimationFrame(gameLoop);
    }

    // ===== 5. 辅助功能 =====

    // 绘制骨架
    function drawPose(ctx, landmarks, color, width) {
        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // MediaPipe 连线索引
        const connections = PoseLandmarker.POSE_CONNECTIONS;
        
        // 绘制连线
        for(const conn of connections) {
            const start = landmarks[conn.start];
            const end = landmarks[conn.end];
            // 只要有一个点置信度不够就不画
            if(start.visibility > 0.5 && end.visibility > 0.5) {
                ctx.beginPath();
                ctx.moveTo(start.x * w, start.y * h);
                ctx.lineTo(end.x * w, end.y * h);
                ctx.stroke();
            }
        }
        
        // 绘制关节
        ctx.fillStyle = color;
        for(const lm of landmarks) {
            if(lm.visibility > 0.5) {
                ctx.beginPath();
                ctx.arc(lm.x * w, lm.y * h, width * 1.5, 0, 2*Math.PI);
                ctx.fill();
            }
        }
    }

    // 更新节奏条
    function updateTimeline(currentTime) {
        // 清空旧的 Notes
        els.timeline.innerHTML = '<div class="hit-zone"></div>';
        
        // 渲染即将到来的 Notes
        // 这里的 20% 是 hit-zone 的 left 属性
        const trackWidth = els.timeline.clientWidth;
        
        refAnalysis.beats.forEach(beat => {
            const diff = beat.time - currentTime;
            // 只显示未来 2秒内的 Note
            if(diff >= -0.2 && diff <= 2) {
                // 计算位置: 0s 在 20% 处 (hit-zone), 2s 在 100% 处
                // 公式：left% = 20% + (diff / 2s) * 80%
                const leftPercent = 20 + (diff / 2) * 80;
                
                const note = document.createElement('div');
                note.className = 'note';
                note.style.left = `${leftPercent}%`;
                // 如果已经判定过，变色
                if(beat.hit) note.style.background = '#fbbf24'; 
                els.timeline.appendChild(note);
            }
        });
    }

    // 判定核心
    function checkHit(currentTime, playerPose, refPose) {
        // 找到最近的一个 Beat
        const beat = refAnalysis.beats.find(b => Math.abs(b.time - currentTime) < 0.15 && !b.hit);
        
        if(beat) {
            // 计算相似度 (简单余弦相似度)
            const sim = calculateSimilarity(playerPose, refPose);
            
            let feedbackClass = '';
            let feedbackText = '';
            let points = 0;

            if(sim > 0.85) {
                feedbackText = 'PERFECT';
                feedbackClass = 'fb-perfect';
                points = 1000;
                combo++;
            } else if(sim > 0.70) {
                feedbackText = 'GOOD';
                feedbackClass = 'fb-good';
                points = 500;
                combo++;
            } else {
                feedbackText = 'MISS';
                feedbackClass = 'fb-miss';
                combo = 0;
            }

            // 标记这个 beat 已经处理过
            beat.hit = true;
            showFeedback(feedbackText, feedbackClass);
            
            score += points + (combo * 10);
            els.score.textContent = score.toString().padStart(6, '0');
            els.combo.textContent = combo;
        }
    }

    // 简易相似度算法 (只算上半身关键向量)
    function calculateSimilarity(poseA, poseB) {
        // 定义要对比的关键向量对 (索引)
        const vectors = [
            [11, 13], [13, 15], // 左臂
            [12, 14], [14, 16], // 右臂
            [11, 12],           // 肩膀
            [23, 24]            // 髋部
        ];

        let totalSim = 0;
        let count = 0;

        for(const [i, j] of vectors) {
            const vA = { x: poseA[j].x - poseA[i].x, y: poseA[j].y - poseA[i].y };
            const vB = { x: poseB[j].x - poseB[i].x, y: poseB[j].y - poseB[i].y };
            
            // 归一化
            const magA = Math.sqrt(vA.x**2 + vA.y**2) + 0.0001;
            const magB = Math.sqrt(vB.x**2 + vB.y**2) + 0.0001;
            
            // 点积
            const dot = (vA.x * vB.x + vA.y * vB.y) / (magA * magB);
            totalSim += dot;
            count++;
        }

        return (totalSim / count + 1) / 2; // 映射到 0~1
    }

    function showFeedback(text, cls) {
        const el = els.feedback;
        el.textContent = text;
        el.className = '';
        void el.offsetWidth; // trigger reflow
        el.classList.add(cls);
    }

  </script>
</body>
</html>