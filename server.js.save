// server.js
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const path = require('path');

console.log('ğŸš€ ä½“æ„Ÿæ¦¨æ±æœºå¤šäººåœ¨çº¿æ¸¸æˆæœåŠ¡å™¨å¯åŠ¨ä¸­...');

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.static('public')); // ç”¨äºå­˜æ”¾é™æ€æ–‡ä»¶

// å¥åº·æ£€æŸ¥ç«¯ç‚¹
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    message: 'ä½“æ„Ÿæ¦¨æ±æœºæ¸¸æˆæœåŠ¡å™¨è¿è¡Œæ­£å¸¸',
    activeRooms: gameRooms.size,
    waitingPlayers: waitingPlayers.length,
    totalConnections: playerSessions.size
  });
});

// æœåŠ¡å™¨çŠ¶æ€é¡µé¢
app.get('/status', (req, res) => {
  const roomList = Array.from(gameRooms.entries()).map(([id, room]) => ({
    roomId: id,
    roomType: room.roomType,
    playerCount: room.getPlayerCount(),
    maxPlayers: room.maxPlayers,
    status: room.status,
    players: room.getPlayerList().map(p => p.username)
  }));

  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
        <title>æ¦¨æ±æœºæ¸¸æˆæœåŠ¡å™¨çŠ¶æ€</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
            .container { max-width: 1000px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; }
            .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
            .stat-card { background: #e3f2fd; padding: 15px; border-radius: 8px; text-align: center; }
            .room-list { margin-top: 20px; }
            .room-card { background: #f3e5f5; margin: 10px 0; padding: 15px; border-radius: 8px; }
            .player-item { display: inline-block; background: #c8e6c9; padding: 5px 10px; margin: 2px; border-radius: 4px; }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>ğŸ® ä½“æ„Ÿæ¦¨æ±æœºæ¸¸æˆæœåŠ¡å™¨çŠ¶æ€</h1>
            <div class="stats">
                <div class="stat-card">
                    <h3>æ´»è·ƒæˆ¿é—´</h3>
                    <div style="font-size: 2em; color: #2196f3;">${gameRooms.size}</div>
                </div>
                <div class="stat-card">
                    <h3>ç­‰å¾…ç©å®¶</h3>
                    <div style="font-size: 2em; color: #ff9800;">${waitingPlayers.length}</div>
                </div>
                <div class="stat-card">
                    <h3>æ€»è¿æ¥æ•°</h3>
                    <div style="font-size: 2em; color: #4caf50;">${playerSessions.size}</div>
                </div>
                <div class="stat-card">
                    <h3>è¿è¡Œæ—¶é—´</h3>
                    <div style="font-size: 1.2em; color: #9c27b0;">${process.uptime().toFixed(0)} ç§’</div>
                </div>
            </div>
            
            <div class="room-list">
                <h2>æ´»è·ƒæˆ¿é—´</h2>
                ${roomList.length === 0 ? 
                  '<p>æš‚æ— æ´»è·ƒæˆ¿é—´</p>' : 
                  roomList.map(room => `
                    <div class="room-card">
                        <h3>æˆ¿é—´ ${room.roomId} (${room.roomType})</h3>
                        <p>çŠ¶æ€: ${room.status} | ç©å®¶: ${room.playerCount}/${room.maxPlayers}</p>
                        <div>ç©å®¶: ${room.players.map(p => `<span class="player-item">${p}</span>`).join('')}</div>
                    </div>
                  `).join('')
                }
            </div>
            
            <div style="margin-top: 30px; color: #666;">
                <p>æœåŠ¡å™¨æ—¶é—´: ${new Date().toISOString()}</p>
                <p>Node.jsç‰ˆæœ¬: ${process.version}</p>
            </div>
        </div>
    </body>
    </html>
  `);
});

// åˆ›å»ºHTTPæœåŠ¡å™¨
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: "*", // å…è®¸æ‰€æœ‰åŸŸåè¿æ¥ï¼ˆç”Ÿäº§ç¯å¢ƒåº”è¯¥é™åˆ¶ï¼‰
    methods: ["GET", "POST"]
  }
});

// æ¸¸æˆé…ç½®
const GAME_CONFIG = {
  MAX_PLAYERS_PER_ROOM: 4,
  MATCHMAKING_TIMEOUT: 30000, // 30ç§’åŒ¹é…è¶…æ—¶
  GAME_DURATION: 30000, // 30ç§’æ¸¸æˆæ—¶é—´
  ROOM_CLEANUP_DELAY: 60000 // æˆ¿é—´æ¸…ç†å»¶è¿Ÿ
};

// æ•°æ®å­˜å‚¨
const gameRooms = new Map();        // roomId -> GameRoom
const waitingPlayers = new Map();   // socketId -> PlayerData
const playerSessions = new Map();   // socketId -> PlayerSession

// æ¸¸æˆæˆ¿é—´ç±»
class GameRoom {
  constructor(roomId, creator, roomType = '1v1') {
    this.roomId = roomId;
    this.roomType = roomType;
    this.players = new Map(); // socketId -> Player
    this.status = 'waiting'; // waiting, playing, finished
    this.createdAt = new Date();
    this.gameStartTime = null;
    this.maxPlayers = this.getMaxPlayers(roomType);
    
    // æ·»åŠ åˆ›å»ºè€…
    this.addPlayer(creator);
    
    console.log(`ğŸ® æ–°æˆ¿é—´åˆ›å»º: ${roomId} ç±»å‹: ${roomType} åˆ›å»ºè€…: ${creator.username}`);
  }

  getMaxPlayers(roomType) {
    const config = {
      '1v1': 2,
      '2v2': 4,
      '4player': 4,
      'freeforall': 8
    };
    return config[roomType] || 2;
  }

  addPlayer(playerData) {
    const player = {
      socketId: playerData.socketId,
      userId: playerData.userId,
      userEmail: playerData.userEmail,
      username: playerData.username,
      score: 0,
      energy: 0,
      rpm: 0,
      connected: true,
      joinedAt: new Date()
    };
    
    this.players.set(playerData.socketId, player);
    console.log(`ğŸ‘¤ ç©å®¶ ${playerData.username} åŠ å…¥æˆ¿é—´ ${this.roomId}`);
    
    return player;
  }

  removePlayer(socketId) {
    const player = this.players.get(socketId);
    if (player) {
      this.players.delete(socketId);
      console.log(`ğŸ‘‹ ç©å®¶ ${player.username} ç¦»å¼€æˆ¿é—´ ${this.roomId}`);
      return player;
    }
    return null;
  }

  updatePlayerState(socketId, rpm, energy) {
    const player = this.players.get(socketId);
    if (player) {
      player.rpm = rpm;
      player.energy = energy;
      player.score = energy; // åˆ†æ•°åŸºäºèƒ½é‡å€¼
    }
  }

  getPlayerCount() {
    return this.players.size;
  }

  getPlayerList() {
    return Array.from(this.players.values()).map(p => ({
      userId: p.userId,
      userEmail: p.userEmail,
      username: p.username,
      score: p.score,
      energy: p.energy,
      rpm: p.rpm
    }));
  }

  canJoin() {
    return this.status === 'waiting' && this.getPlayerCount() < this.maxPlayers;
  }

  startGame() {
    this.status = 'playing';
    this.gameStartTime = new Date();
    console.log(`ğŸ¯ æˆ¿é—´ ${this.roomId} æ¸¸æˆå¼€å§‹ï¼Œç©å®¶æ•°: ${this.getPlayerCount()}`);
  }

  isGameFinished() {
    if (this.status !== 'playing') return false;
    const gameTime = new Date() - this.gameStartTime;
    return gameTime >= GAME_CONFIG.GAME_DURATION;
  }

  getGameResults() {
    const players = this.getPlayerList();
    players.sort((a, b) => b.score - a.score);
    
    return {
      winner: players[0],
      rankings: players,
      roomId: this.roomId,
      finishedAt: new Date()
    };
  }
}

// Socket.io è¿æ¥å¤„ç†
io.on('connection', (socket) => {
  console.log('ğŸ”— æ–°è¿æ¥:', socket.id);

  // ç©å®¶è®¤è¯
  socket.on('player_authenticate', (playerData) => {
    const { userId, userEmail, username } = playerData;
    
    if (!userId || !userEmail) {
      socket.emit('auth_error', { message: 'ç¼ºå°‘ç”¨æˆ·ä¿¡æ¯' });
      return;
    }

    // å­˜å‚¨ç©å®¶ä¼šè¯
    playerSessions.set(socket.id, {
      userId,
      userEmail,
      username: username || userEmail.split('@')[0],
      connectedAt: new Date(),
      currentRoom: null
    });

    socket.emit('auth_success', { 
      message: 'è®¤è¯æˆåŠŸ',
      playerId: socket.id,
      username: username || userEmail.split('@')[0]
    });

    console.log(`âœ… ç©å®¶è®¤è¯: ${userEmail} (${socket.id})`);
  });

  // å¿«é€ŸåŒ¹é…
  socket.on('quick_match', (matchData) => {
    const playerSession = playerSessions.get(socket.id);
    if (!playerSession) {
      socket.emit('match_error', { message: 'è¯·å…ˆè®¤è¯' });
      return;
    }

    const roomType = matchData.roomType || '1v1';
    console.log(`ğŸ¯ å¿«é€ŸåŒ¹é…è¯·æ±‚: ${playerSession.username} ç±»å‹: ${roomType}`);

    // å¯»æ‰¾åˆé€‚çš„æˆ¿é—´
    let foundRoom = null;
    for (const [roomId, room] of gameRooms.entries()) {
      if (room.roomType === roomType && room.canJoin()) {
        foundRoom = room;
        break;
      }
    }

    if (foundRoom) {
      // åŠ å…¥ç°æœ‰æˆ¿é—´
      joinRoom(socket, foundRoom.roomId, playerSession);
    } else {
      // åˆ›å»ºæ–°æˆ¿é—´å¹¶ç­‰å¾…
      const newRoom = createNewRoom(socket, playerSession, roomType);
      waitingPlayers.set(socket.id, {
        playerData: playerSession,
        roomType: roomType,
        joinedAt: new Date()
      });
      
      socket.emit('matchmaking_waiting', {
        roomId: newRoom.roomId,
        roomType: roomType,
        message: `ç­‰å¾…å…¶ä»–ç©å®¶åŠ å…¥... (1/${newRoom.maxPlayers})`
      });
    }
  });

  // åˆ›å»ºç§äººæˆ¿é—´
  socket.on('create_private_room', (roomData) => {
    const playerSession = playerSessions.get(socket.id);
    if (!playerSession) {
      socket.emit('room_error', { message: 'è¯·å…ˆè®¤è¯' });
      return;
    }

    const roomType = roomData.roomType || '1v1';
    const room = createNewRoom(socket, playerSession, roomType, true);
    
    socket.emit('private_room_created', {
      roomId: room.roomId,
      roomType: roomType,
      maxPlayers: room.maxPlayers,
      shareLink: `${room.roomId}`,
      message: 'ç§äººæˆ¿é—´å·²åˆ›å»ºï¼Œåˆ†äº«æˆ¿é—´ç ç»™æœ‹å‹'
    });

    console.log(`ğŸ” ç§äººæˆ¿é—´åˆ›å»º: ${room.roomId} by ${playerSession.username}`);
  });

  // åŠ å…¥ç§äººæˆ¿é—´
  socket.on('join_private_room', (joinData) => {
    const playerSession = playerSessions.get(socket.id);
    if (!playerSession) {
      socket.emit('join_error', { message: 'è¯·å…ˆè®¤è¯' });
      return;
    }

    const { roomId } = joinData;
    joinRoom(socket, roomId, playerSession);
  });

  // æ¸¸æˆçŠ¶æ€æ›´æ–°
  socket.on('game_update', (gameData) => {
    const { roomId, rpm, energy } = gameData;
    const room = gameRooms.get(roomId);
    
    if (!room) {
      socket.emit('game_error', { message: 'æˆ¿é—´ä¸å­˜åœ¨' });
      return;
    }

    room.updatePlayerState(socket.id, rpm, energy);

    // å¹¿æ’­ç»™æˆ¿é—´å†…å…¶ä»–ç©å®¶
    socket.to(roomId).emit('players_update', {
      players: room.getPlayerList(),
      timestamp: new Date()
    });

    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
    if (room.isGameFinished()) {
      finishGame(room);
    }
  });

  // ç¦»å¼€æˆ¿é—´
  socket.on('leave_room', () => {
    leaveRoom(socket.id);
  });

  // æ–­å¼€è¿æ¥
  socket.on('disconnect', () => {
    console.log('âŒ è¿æ¥æ–­å¼€:', socket.id);
    leaveRoom(socket.id);
    waitingPlayers.delete(socket.id);
    playerSessions.delete(socket.id);
  });

  // å¿ƒè·³æ£€æµ‹
  socket.on('ping', () => {
    socket.emit('pong', { timestamp: new Date().toISOString() });
  });
});

// æˆ¿é—´ç®¡ç†å‡½æ•°
function createNewRoom(socket, playerData, roomType, isPrivate = false) {
  const roomId = generateRoomId();
  const room = new GameRoom(roomId, {
    socketId: socket.id,
    ...playerData
  }, roomType);
  
  gameRooms.set(roomId, room);
  playerSessions.get(socket.id).currentRoom = roomId;
  socket.join(roomId);
  
  return room;
}

function joinRoom(socket, roomId, playerData) {
  const room = gameRooms.get(roomId);
  
  if (!room) {
    socket.emit('join_error', { message: 'æˆ¿é—´ä¸å­˜åœ¨' });
    return false;
  }

  if (!room.canJoin()) {
    socket.emit('join_error', { message: 'æˆ¿é—´å·²æ»¡' });
    return false;
  }

  // åŠ å…¥æˆ¿é—´
  room.addPlayer({
    socketId: socket.id,
    ...playerData
  });
  
  playerSessions.get(socket.id).currentRoom = roomId;
  socket.join(roomId);
  waitingPlayers.delete(socket.id);

  console.log(`âœ… ç©å®¶ ${playerData.username} åŠ å…¥æˆ¿é—´ ${roomId} (${room.getPlayerCount()}/${room.maxPlayers})`);

  // é€šçŸ¥æ‰€æœ‰ç©å®¶
  io.to(roomId).emit('player_joined', {
    newPlayer: {
      userId: playerData.userId,
      userEmail: playerData.userEmail,
      username: playerData.username
    },
    roomInfo: {
      roomId: roomId,
      roomType: room.roomType,
      players: room.getPlayerList(),
      playerCount: room.getPlayerCount(),
      maxPlayers: room.maxPlayers
    },
    message: `ç©å®¶ ${playerData.username} åŠ å…¥äº†æ¸¸æˆ`
  });

  // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹æ¸¸æˆ
  if (room.getPlayerCount() >= room.maxPlayers) {
    setTimeout(() => {
      if (room.status === 'waiting') {
        startRoomGame(room);
      }
    }, 2000);
  }

  return true;
}

function leaveRoom(socketId) {
  const playerSession = playerSessions.get(socketId);
  if (!playerSession || !playerSession.currentRoom) return;

  const roomId = playerSession.currentRoom;
  const room = gameRooms.get(roomId);
  
  if (room) {
    const leftPlayer = room.removePlayer(socketId);
    
    if (leftPlayer) {
      // é€šçŸ¥å…¶ä»–ç©å®¶
      io.to(roomId).emit('player_left', {
        leftPlayer: {
          userId: leftPlayer.userId,
          userEmail: leftPlayer.userEmail
        },
        message: `ç©å®¶ ${leftPlayer.username} ç¦»å¼€äº†æ¸¸æˆ`,
        remainingPlayers: room.getPlayerList()
      });

      // å¦‚æœæˆ¿é—´ç©ºäº†ï¼Œæ¸…ç†æˆ¿é—´
      if (room.getPlayerCount() === 0) {
        setTimeout(() => {
          if (room.getPlayerCount() === 0) {
            gameRooms.delete(roomId);
            console.log(`ğŸ§¹ æ¸…ç†ç©ºæˆ¿é—´: ${roomId}`);
          }
        }, 5000);
      }
    }
  }

  playerSession.currentRoom = null;
}

function startRoomGame(room) {
  room.startGame();
  
  io.to(room.roomId).emit('game_start', {
    roomId: room.roomId,
    duration: GAME_CONFIG.GAME_DURATION,
    startTime: new Date(),
    players: room.getPlayerList(),
    message: 'æ¸¸æˆå¼€å§‹ï¼è½¬åŠ¨èº«ä½“åˆ¶ä½œæœæ±ï¼'
  });

  console.log(`ğŸ¯ æ¸¸æˆå¼€å§‹: ${room.roomId} ç©å®¶æ•°: ${room.getPlayerCount()}`);

  // è®¾ç½®æ¸¸æˆç»“æŸæ£€æŸ¥
  const gameInterval = setInterval(() => {
    if (room.isGameFinished()) {
      clearInterval(gameInterval);
      finishGame(room);
    }
  }, 1000);
}

function finishGame(room) {
  const results = room.getGameResults();
  room.status = 'finished';
  
  io.to(room.roomId).emit('game_finished', results);
  
  console.log(`ğŸ æ¸¸æˆç»“æŸ: ${room.roomId} è·èƒœè€…: ${results.winner.username}`);
  
  // å»¶è¿Ÿæ¸…ç†æˆ¿é—´
  setTimeout(() => {
    if (gameRooms.get(room.roomId) === room) {
      gameRooms.delete(room.roomId);
      console.log(`ğŸ§¹ æ¸…ç†å®Œæˆæˆ¿é—´: ${room.roomId}`);
    }
  }, GAME_CONFIG.ROOM_CLEANUP_DELAY);
}

// å·¥å…·å‡½æ•°
function generateRoomId() {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}

// å®šæœŸæ¸…ç†
setInterval(() => {
  const now = new Date();
  
  // æ¸…ç†è¶…æ—¶çš„ç­‰å¾…ç©å®¶
  for (const [socketId, waiting] of waitingPlayers.entries()) {
    if (now - waiting.joinedAt > GAME_CONFIG.MATCHMAKING_TIMEOUT) {
      waitingPlayers.delete(socketId);
      const socket = io.sockets.sockets.get(socketId);
      if (socket) {
        socket.emit('matchmaking_timeout', {
          message: 'åŒ¹é…è¶…æ—¶ï¼Œè¯·é‡è¯•'
        });
      }
    }
  }
  
  console.log(`ğŸ•’ å®šæ—¶æ¸…ç† - æ´»è·ƒæˆ¿é—´: ${gameRooms.size}, ç­‰å¾…ç©å®¶: ${waitingPlayers.size}`);
}, 30000);

// å¯åŠ¨æœåŠ¡å™¨
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`ğŸ® ä½“æ„Ÿæ¦¨æ±æœºå¤šäººåœ¨çº¿æ¸¸æˆæœåŠ¡å™¨è¿è¡Œä¸­!`);
  console.log(`ğŸ“ ç«¯å£: ${PORT}`);
  console.log(`ğŸŒ å¥åº·æ£€æŸ¥: http://localhost:${PORT}/health`);
  console.log(`ğŸ“Š çŠ¶æ€é¡µé¢: http://localhost:${PORT}/status`);
  console.log(`ğŸ•’ å¯åŠ¨æ—¶é—´: ${new Date().toISOString()}`);
  console.log(`ğŸ’¡ æ”¯æŒçš„æˆ¿é—´ç±»å‹: 1v1, 2v2, 4player, freeforall`);
});

// ä¼˜é›…å…³é—­
process.on('SIGTERM', () => {
  console.log('ğŸ›‘ æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œæ­£åœ¨æ¸…ç†...');
  server.close(() => {
    console.log('âœ… æœåŠ¡å™¨å·²å…³é—­');
    process.exit(0);
  });
});
